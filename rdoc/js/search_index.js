var search_data = {"index":{"searchIndex":["lookuptable","classmethods","look_up_table()","lut()","lut_cache_exists?()","lut_deep_hash_call()","lut_init()","lut_keys()","lut_options()","lut_proc()","lut_read()","lut_read_cache_item()","lut_read_from_cache()","lut_read_without_cache()","lut_read_without_cache_no_sql_mode()","lut_read_without_cache_sql_mode()","lut_reload()","lut_reset()","lut_set_options()","lut_set_proc()","lut_write_cache_item()","lut_write_to_cache()","lut_write_to_cache_no_sql_mode()","lut_write_to_cache_sql_mode()","method_missing()","respond_to?()","readme"],"longSearchIndex":["lookuptable","lookuptable::classmethods","lookuptable::classmethods#look_up_table()","lookuptable::classmethods#lut()","lookuptable::classmethods#lut_cache_exists?()","lookuptable::classmethods#lut_deep_hash_call()","lookuptable::classmethods#lut_init()","lookuptable::classmethods#lut_keys()","lookuptable::classmethods#lut_options()","lookuptable::classmethods#lut_proc()","lookuptable::classmethods#lut_read()","lookuptable::classmethods#lut_read_cache_item()","lookuptable::classmethods#lut_read_from_cache()","lookuptable::classmethods#lut_read_without_cache()","lookuptable::classmethods#lut_read_without_cache_no_sql_mode()","lookuptable::classmethods#lut_read_without_cache_sql_mode()","lookuptable::classmethods#lut_reload()","lookuptable::classmethods#lut_reset()","lookuptable::classmethods#lut_set_options()","lookuptable::classmethods#lut_set_proc()","lookuptable::classmethods#lut_write_cache_item()","lookuptable::classmethods#lut_write_to_cache()","lookuptable::classmethods#lut_write_to_cache_no_sql_mode()","lookuptable::classmethods#lut_write_to_cache_sql_mode()","lookuptable::classmethods#method_missing()","lookuptable::classmethods#respond_to?()",""],"info":[["LookUpTable","","LookUpTable.html","","<p>CHECK: fail if Numbers as keys? TODO: Doc :look_up_table =&gt; options\n"],["LookUpTable::ClassMethods","","LookUpTable/ClassMethods.html","",""],["look_up_table","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-look_up_table","(lut_key, options = {}, &block)","<p>Defining LookUpTables\n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># Sample class:</span>\n<span class=\"ruby-constant\">Foobar</span>(<span class=\"ruby-identifier\">id</span><span class=\"ruby-operator\">:</span> <span class=\"ruby-identifier\">integer</span>, <span class=\"ruby-identifier\">foo</span><span class=\"ruby-operator\">:</span> <span class=\"ruby-identifier\">string</span>, <span class=\"ruby-identifier\">bar</span><span class=\"ruby-operator\">:</span> <span class=\"ruby-identifier\">integer</span>)\n</pre>\n<p>Simplest way to define …\n"],["lut","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut","(lut_key = nil, lut_item_key = nil)","<p>Calling LookUpTables\n<p>Call without any params\n<p>Returns: All LUTs defined within Foobar\n"],["lut_cache_exists?","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_cache_exists-3F","(name)","<p>Cache entry for given LUT exists?\n"],["lut_deep_hash_call","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_deep_hash_call","(method, deep_hash, key, item_key)",""],["lut_init","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_init","(lut_key = nil)","<p>Init complete LUT with all keys define. But won’t rewrite cache if allready\nwritten!\n<p>Returns: Foobar.lut_keys …\n"],["lut_keys","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_keys","()","<p>Returns: Keys of LookUpTables defined\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Foobar</span>.<span class=\"ruby-identifier\">lut_keys</span>\n=<span class=\"ruby-operator\">&gt;</span> [:<span class=\"ruby-identifier\">id</span>, :<span class=\"ruby-identifier\">foo</span>, :<span class=\"ruby-identifier\">bar</span>, :<span class=\"ruby-identifier\">foobar</span>]\n</pre>\n"],["lut_options","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_options","(lut_key = nil, option_key = nil)","<p>Returns: Options defined\n<p>Accept same params as: Foobar.lut\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Foobar</span>.<span class=\"ruby-identifier\">lut_options</span> :<span class=\"ruby-identifier\">foobar</span>\n=<span class=\"ruby-operator\">&gt;</span>\n  {\n    :<span class=\"ruby-identifier\">batch_size=</span><span class=\"ruby-operator\">&gt;</span><span class=\"ruby-value\">10000</span>, <span class=\"ruby-operator\">...</span>\n</pre>\n"],["lut_proc","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_proc","(lut_key = nil)",""],["lut_read","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_read","(name)","<p>Reads a single lut\n"],["lut_read_cache_item","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_read_cache_item","(lut_key, lut_item_key)","<p>Reads a single item of a LookUpTable from Cache\n"],["lut_read_from_cache","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_read_from_cache","(name)","<p>Reads a complete lut from cache HACK: this still looks ugly somehow\n"],["lut_read_without_cache","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_read_without_cache","(lut_key)","<p>Reads a complete from given block or generic version HACK: some duplicated\nmethods from Class.lut_write_to_cache …\n"],["lut_read_without_cache_no_sql_mode","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_read_without_cache_no_sql_mode","(lut_key)","<p>CHECK: ugly method_name\n"],["lut_read_without_cache_sql_mode","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_read_without_cache_sql_mode","(lut_key)","<p>CHECK: somehow long method\n"],["lut_reload","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_reload","(lut_key = nil)","<p>Reading LUT and writing cache again\n"],["lut_reset","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_reset","(lut_key = nil)","<p>Reset complete lut if name is omitted, resets given lut otherwise. HACK:\nnot cool do access and define …\n"],["lut_set_options","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_set_options","(lut_key, options)","<p>lut_set_options(lut_name, options) / lut_options(lut_name)\n"],["lut_set_proc","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_set_proc","(lut_key, block)","<p>lut_set_proc(lut_name, block) / lut_proc(lut_name)\n"],["lut_write_cache_item","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_write_cache_item","(lut_key, lut_item_count, lut_data)","<p>Write a single Item into LookUpTable-Cache TODO: refactor\n"],["lut_write_to_cache","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_write_to_cache","(lut_key)","<p>Write a LookUpTable into Cache\n"],["lut_write_to_cache_no_sql_mode","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_write_to_cache_no_sql_mode","(lut_key)","<p>HACK: somehow long method\n"],["lut_write_to_cache_sql_mode","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-lut_write_to_cache_sql_mode","(lut_key)","<p>HACK: somehow long method\n"],["method_missing","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-method_missing","(sym, *args, &block)","<p>Delegating &lt;attribute&gt;_lut(args) method calls e.g.: Klass.foo_lut\n=&gt; Klass.lut :foo\n"],["respond_to?","LookUpTable::ClassMethods","LookUpTable/ClassMethods.html#method-i-respond_to-3F","(sym, bool)","<p>CHECK: what’s bool?\n"],["README","","README_rdoc.html","","<p>LookUpTable\n<p>*STILL IN DEVELOPMENT!* &mdash; <p>Requirements:\n<p>Rails 3.x\n"]]}}